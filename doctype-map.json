{
  "version": "1.0",
  "entries": [
    {
      "id": "a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d",
      "codeRef": {
        "filePath": "src/cli/check.ts",
        "symbolName": "checkCommand"
      },
      "codeSignatureHash": "834d841a0878511bc393222b9fd9dc7a841bdeff42924af13a59b95e158a68ce",
      "docRef": {
        "filePath": "docs/cli/check.md",
        "startLine": 88,
        "endLine": 99
      },
      "originalMarkdownContent": "The check command performs the following steps:\n\n1. Loads the doctype-map.json file using DoctypeMapManager\n2. For each entry in the map:\n   - Reads the source file specified in code_ref\n   - Analyzes the symbol using ASTAnalyzer\n   - Calculates the current signature hash using SignatureHasher\n   - Compares with the saved hash\n3. Reports all detected drifts\n4. Exits with appropriate status code",
      "lastUpdated": 1764259025172
    },
    {
      "id": "b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d6e",
      "codeRef": {
        "filePath": "src/cli/fix.ts",
        "symbolName": "fixCommand"
      },
      "codeSignatureHash": "33c444cb7aa89dac2c18682f513857f7b079a7f14174c7bbc2344dcc340bf322",
      "docRef": {
        "filePath": "docs/cli/fix.md",
        "startLine": 107,
        "endLine": 119
      },
      "originalMarkdownContent": "The fix command performs the following steps:\n\n1. Runs drift detection using DriftDetector\n2. For each drifted entry:\n   - Extracts old and new code signatures\n   - Prepares context for GenAI (Phase 4)\n   - Updates the hash in doctype-map.json\n3. In Phase 4, will also:\n   - Generate new documentation content via LLM\n   - Inject content using ContentInjector\n   - Optionally commit changes to git",
      "lastUpdated": 1764259025252
    },
    {
      "id": "c3d4e5f6-a7b8-4c9d-0e1f-2a3b4c5d6e7f",
      "codeRef": {
        "filePath": "src/core/ast-analyzer.ts",
        "symbolName": "ASTAnalyzer"
      },
      "codeSignatureHash": "a2f0cc7e66d372899d047ad3726ce515a302aa1ef81f08069be8c83f633cf152",
      "docRef": {
        "filePath": "docs/api/ast-analyzer.md",
        "startLine": 6,
        "endLine": 16
      },
      "originalMarkdownContent": "The ASTAnalyzer class is the core component for deterministic code analysis. It uses ts-morph (a wrapper around the TypeScript Compiler API) to parse TypeScript files and extract public API signatures from exported symbols.\n\nSupported symbol types:\n- Functions and arrow functions\n- Classes (with properties and methods)\n- Interfaces\n- Type aliases\n- Enums\n- Exported variables and constants",
      "lastUpdated": 1764259025257
    },
    {
      "id": "b8c9d0e1-f2a3-4b4c-5d6e-7f8a9b0c1d2e",
      "codeRef": {
        "filePath": "src/core/signature-hasher.ts",
        "symbolName": "SignatureHasher"
      },
      "codeSignatureHash": "21cd1dacf5bff3c741b73f2880dee729206d928f05d50503c4a21cfd9b365966",
      "docRef": {
        "filePath": "docs/api/signature-hasher.md",
        "startLine": 6,
        "endLine": 13
      },
      "originalMarkdownContent": "The SignatureHasher class provides deterministic hash generation for code signatures. It uses SHA256 to create a unique fingerprint of a symbol's public API, enabling reliable drift detection.\n\nThe hasher normalizes signatures before hashing to ensure:\n- Whitespace differences don't affect the hash\n- Comment changes don't trigger false positives\n- Only meaningful API changes are detected",
      "lastUpdated": 1764259025259
    },
    {
      "id": "d6e7f8a9-b0c1-4d2e-3f4a-5b6c7d8e9f0a",
      "codeRef": {
        "filePath": "src/content/map-manager.ts",
        "symbolName": "DoctypeMapManager"
      },
      "codeSignatureHash": "18a45eb559217111395a840ab7c3ecb289d58186b28c9336d67e4166d7341ef8",
      "docRef": {
        "filePath": "docs/api/map-manager.md",
        "startLine": 6,
        "endLine": 14
      },
      "originalMarkdownContent": "# `DoctypeMapManager` Class\n\nThe `DoctypeMapManager` class provides methods to manage a collection of `DoctypeMapEntry` objects. It allows you to add, update, remove entries, and perform various queries on the collection.\n\n## Methods\n\n### `save(): void`\n\nThis method saves the current state of the `DoctypeMapManager` instance. It does not take any parameters and does not return any value.\n\n### `getEntries(): DoctypeMapEntry[]`\n\nThis method returns all entries in the `DoctypeMapManager` instance.\n\n**Returns:** An array of `DoctypeMapEntry` objects.\n\n### `getEntryById(id: string): DoctypeMapEntry`\n\nThis method retrieves a specific entry by its ID.\n\n**Parameters:**\n- `id: string` - The ID of the entry to retrieve.\n\n**Returns:** The `DoctypeMapEntry` object with the specified ID.\n\n### `getEntriesByCodeRef(filePath: string, symbolName: string): DoctypeMapEntry[]`\n\nThis method retrieves entries by their code reference.\n\n**Parameters:**\n- `filePath: string` - The file path of the code reference.\n- `symbolName: string` - The symbol name of the code reference.\n\n**Returns:** An array of `DoctypeMapEntry` objects that match the specified code reference.\n\n### `getEntriesByDocFile(filePath: string): DoctypeMapEntry[]`\n\nThis method retrieves entries by their documentation file.\n\n**Parameters:**\n- `filePath: string` - The file path of the documentation file.\n\n**Returns:** An array of `DoctypeMapEntry` objects that match the specified documentation file.\n\n### `addEntry(entry: DoctypeMapEntry): void`\n\nThis method adds a new entry to the `DoctypeMapManager` instance.\n\n**Parameters:**\n- `entry: DoctypeMapEntry` - The entry to add.\n\n### `updateEntry(id: string, updates: Partial<DoctypeMapEntry>): void`\n\nThis method updates an existing entry in the `DoctypeMapManager` instance.\n\n**Parameters:**\n- `id: string` - The ID of the entry to update.\n- `updates: Partial<DoctypeMapEntry>` - An object containing the fields to update.\n\n### `removeEntry(id: string): boolean`\n\nThis method removes an entry from the `DoctypeMapManager` instance.\n\n**Parameters:**\n- `id: string` - The ID of the entry to remove.\n\n**Returns:** A boolean indicating whether the removal was successful.\n\n### `hasDrift(id: string, currentHash: string): boolean`\n\nThis method checks if an entry has drifted.\n\n**Parameters:**\n- `id: string` - The ID of the entry to check.\n- `currentHash: string` - The current hash of the entry.\n\n**Returns:** A boolean indicating whether the entry has drifted.\n\n### `getDriftedEntries(currentHashes: Map<string, string>): DoctypeMapEntry[]`\n\nThis method retrieves all entries that have drifted.\n\n**Parameters:**\n- `currentHashes: Map<string, string>` - A map of current hashes.\n\n**Returns:** An array of `DoctypeMapEntry` objects that have drifted.\n\n### `getEntryCount(): number`\n\nThis method returns the number of entries in the `DoctypeMapManager` instance.\n\n**Returns:** The number of entries.\n\n### `clear(): void`\n\nThis method clears all entries in the `DoctypeMapManager` instance. It does not take any parameters and does not return any value.\n\n### `getVersion(): string`\n\nThis method returns the version of the `DoctypeMapManager` instance.\n\n**Returns:** The version as a string.\n\n### `export(): DoctypeMap`\n\nThis method exports the current state of the `DoctypeMapManager` instance.\n\n**Returns:** A `DoctypeMap` object representing the current state.\n\n## Example Usage\n\n```typescript\nconst manager = new DoctypeMapManager();\nmanager.addEntry(new DoctypeMapEntry('id1', 'filePath1', 'symbolName1', 'docFilePath1', 'hash1'));\nmanager.addEntry(new DoctypeMapEntry('id2', 'filePath2', 'symbolName2', 'docFilePath2', 'hash2'));\nconsole.log(manager.getEntryCount()); // Outputs: 2\nconsole.log(manager.getEntryById('id1')); // Outputs: DoctypeMapEntry object with id 'id1'\nmanager.removeEntry('id1');\nconsole.log(manager.getEntryCount()); // Outputs: 1\n```",
      "lastUpdated": 1764262231832,
      "codeSignatureText": "class DoctypeMapManager{;save(): void;getEntries(): import(\"/Users/alessio/Documents/doctype/src/core/types\").DoctypeMapEntry[];getEntryById(id: string): import(\"/Users/alessio/Documents/doctype/src/core/types\").DoctypeMapEntry;getEntriesByCodeRef(filePath: string, symbolName: string): import(\"/Users/alessio/Documents/doctype/src/core/types\").DoctypeMapEntry[];getEntriesByDocFile(filePath: string): import(\"/Users/alessio/Documents/doctype/src/core/types\").DoctypeMapEntry[];addEntry(entry: import(\"/Users/alessio/Documents/doctype/src/core/types\").DoctypeMapEntry): void;updateEntry(id: string, updates: Partial<import(\"/Users/alessio/Documents/doctype/src/core/types\").DoctypeMapEntry>): void;removeEntry(id: string): boolean;hasDrift(id: string, currentHash: string): boolean;getDriftedEntries(currentHashes: Map<string, string>): import(\"/Users/alessio/Documents/doctype/src/core/types\").DoctypeMapEntry[];getEntryCount(): number;clear(): void;getVersion(): string;export(): import(\"/Users/alessio/Documents/doctype/src/core/types\").DoctypeMap}"
    },
    {
      "id": "b6c7d8e9-f0a1-4b2c-3d4e-5f6a7b8c9d0e",
      "codeRef": {
        "filePath": "src/content/content-injector.ts",
        "symbolName": "ContentInjector"
      },
      "codeSignatureHash": "9a3bf739e72a26d04bd97b48eba24de4d7eb4e9ab3c7c27499cf3a0e6f4b04d9",
      "docRef": {
        "filePath": "docs/api/content-injector.md",
        "startLine": 6,
        "endLine": 15
      },
      "originalMarkdownContent": "# `ContentInjector` Class\n\nThe `ContentInjector` class provides methods for injecting content into files or strings at specific anchor points. It also provides methods for previewing the results of these injections, validating anchors, and retrieving the location of anchors within files or strings.\n\n## Methods\n\n### `injectIntoFile(filePath: string, anchorId: string, newContent: string, writeToFile: boolean): InjectionResult`\n\nInjects `newContent` at the location of `anchorId` within the file specified by `filePath`. If `writeToFile` is `true`, the changes are written directly to the file.\n\n- `filePath: string` - The path to the file where the content will be injected.\n- `anchorId: string` - The identifier of the anchor where the content will be injected.\n- `newContent: string` - The content to be injected.\n- `writeToFile: boolean` - If `true`, the file will be updated with the new content.\n\nReturns an `InjectionResult` object representing the result of the injection.\n\n### `injectIntoContent(content: string, anchorId: string, newContent: string): InjectionResult`\n\nInjects `newContent` at the location of `anchorId` within the provided `content` string.\n\n- `content: string` - The string where the content will be injected.\n- `anchorId: string` - The identifier of the anchor where the content will be injected.\n- `newContent: string` - The content to be injected.\n\nReturns an `InjectionResult` object representing the result of the injection.\n\n### `injectMultiple(filePath: string, injections: Map<string, string>, writeToFile: boolean): InjectionResult[]`\n\nInjects multiple content strings at their corresponding anchor locations within the file specified by `filePath`. If `writeToFile` is `true`, the changes are written directly to the file.\n\n- `filePath: string` - The path to the file where the content will be injected.\n- `injections: Map<string, string>` - A map where the keys are anchor identifiers and the values are the corresponding content strings to be injected.\n- `writeToFile: boolean` - If `true`, the file will be updated with the new content.\n\nReturns an array of `InjectionResult` objects representing the results of the injections.\n\n### `preview(filePath: string, anchorId: string, newContent: string): InjectionResult`\n\nPreviews the result of injecting `newContent` at the location of `anchorId` within the file specified by `filePath` without actually modifying the file.\n\n- `filePath: string` - The path to the file where the content will be injected.\n- `anchorId: string` - The identifier of the anchor where the content will be injected.\n- `newContent: string` - The content to be injected.\n\nReturns an `InjectionResult` object representing the result of the injection.\n\n### `getAnchorLocation(filePath: string, anchorId: string): {startLine: number, endLine: number}`\n\nRetrieves the location of `anchorId` within the file specified by `filePath`.\n\n- `filePath: string` - The path to the file where the anchor is located.\n- `anchorId: string` - The identifier of the anchor.\n\nReturns an object with `startLine` and `endLine` properties representing the start and end lines of the anchor within the file.\n\n### `getAnchorLocationFromContent(content: string, anchorId: string): {startLine: number, endLine: number}`\n\nRetrieves the location of `anchorId` within the provided `content` string.\n\n- `content: string` - The string where the anchor is located.\n- `anchorId: string` - The identifier of the anchor.\n\nReturns an object with `startLine` and `endLine` properties representing the start and end lines of the anchor within the string.\n\n### `validateAnchor(content: string, anchorId: string): string[]`\n\nValidates the existence of `anchorId` within the provided `content` string.\n\n- `content: string` - The string where the anchor is located.\n- `anchorId: string` - The identifier of the anchor.\n\nReturns an array of error messages if the anchor is not valid, or an empty array if the anchor is valid.\n\n## Usage Example\n\n```typescript\nconst injector = new ContentInjector();\nconst filePath = './test.txt';\nconst anchorId = 'anchor1';\nconst newContent = 'New content to be injected';\n\n// Inject new content into file\nconst result = injector.injectIntoFile(filePath, anchorId, newContent, true);\n\nconsole.log(result); // Logs the InjectionResult object\n```",
      "lastUpdated": 1764262258345,
      "codeSignatureText": "class ContentInjector{;injectIntoFile(filePath: string, anchorId: string, newContent: string, writeToFile: boolean): import(\"/Users/alessio/Documents/doctype/src/content/content-injector\").InjectionResult;injectIntoContent(content: string, anchorId: string, newContent: string): import(\"/Users/alessio/Documents/doctype/src/content/content-injector\").InjectionResult;injectMultiple(filePath: string, injections: Map<string, string>, writeToFile: boolean): import(\"/Users/alessio/Documents/doctype/src/content/content-injector\").InjectionResult[];preview(filePath: string, anchorId: string, newContent: string): import(\"/Users/alessio/Documents/doctype/src/content/content-injector\").InjectionResult;getAnchorLocation(filePath: string, anchorId: string): {startLine: number;endLine: number;};getAnchorLocationFromContent(content: string, anchorId: string): {startLine: number;endLine: number;};validateAnchor(content: string, anchorId: string): string[]}"
    }
  ]
}